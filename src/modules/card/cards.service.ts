import { BadRequestException, Injectable, Logger } from "@nestjs/common";
import { InjectModel } from "@nestjs/sequelize";
import { Card } from "./models/card.model";
import { CreateCardDTO } from "./dto/create-card.dto";
import { UpdateCardDTO } from "./dto/update-card.dto";
import { AppError } from "../../common/constants/errors";
import { Op } from "sequelize"; // Импортируем Op из sequelize

@Injectable()
export class CardsService {
  private readonly logger = new Logger(CardsService.name);

  constructor(
    @InjectModel(Card) private readonly cardRepository: typeof Card,
    @InjectModel(Card)
    private readonly cardModel: typeof Card,
  ) {}

  // create new Card
  async createCard(
    userId: number,
    createCardDTO: CreateCardDTO,
  ): Promise<Card> {
    const cardCount = await this.cardRepository.count({ where: { userId } });
    const newCard = await this.cardRepository.create({
      userId,
      ...createCardDTO,
      order: cardCount + 1,
    });
    this.logger.log("Card successfully created for user id: " + userId);
    return newCard;
  }

  // get all cards
  async getAllCards(userId: number): Promise<Card[]> {
    const cards = await this.cardRepository.findAll({
      where: { userId },
      order: [["order", "DESC"]], // Сортировка по полю order
    });
    this.logger.log("Retrieved cards for user id: " + userId);
    return cards;
  }

  // update card
  async updateCard(
    userId: number,
    cardId: string,
    updateCardDTO: UpdateCardDTO,
  ): Promise<Card> {
    const card = await this.cardRepository.findOne({
      where: { id: cardId, userId },
    });

    if (!card) {
      throw new BadRequestException(AppError.CARD_NOT_FOUND);
    }

    if (updateCardDTO.order !== undefined) {
      await this.reorderCards(userId, card.order, updateCardDTO.order);
      card.order = updateCardDTO.order;
    }

    await card.update(updateCardDTO);
    this.logger.log("Card successfully updated for user id: " + userId);
    return card;
  }

  // helper method to reorder cards
  private async reorderCards(
    userId: number,
    currentOrder: number,
    newOrder: number,
  ): Promise<void> {
    if (currentOrder < newOrder) {
      await this.cardRepository.increment("order", {
        by: -1,
        where: {
          userId,
          order: {
            $gt: currentOrder,
            $lte: newOrder,
          },
        },
      });
    } else if (currentOrder > newOrder) {
      await this.cardRepository.increment("order", {
        by: 1,
        where: {
          userId,
          order: {
            $lt: currentOrder,
            $gte: newOrder,
          },
        },
      });
    }
  }

  // Метод для обновления порядка карточек
  async updateCardOrders(
    userId: number,
    updatedOrders: { id: string; order: number }[],
  ): Promise<void> {
    const transaction = await this.cardRepository.sequelize.transaction();

    try {
      for (const { id, order } of updatedOrders) {
        await this.cardRepository.update(
          { order },
          {
            where: {
              id,
              userId,
            },
            transaction,
          },
        );
      }

      await transaction.commit();
      this.logger.log(
        `Card orders successfully updated for user id: ${userId}`,
      );
    } catch (error) {
      await transaction.rollback();
      this.logger.error(
        `Failed to update card orders for user id: ${userId}`,
        error.stack,
      );
      throw error;
    }
  }

  // Метод для получения одной карточки по ID
  async getCardById(userId: number, cardId: string): Promise<Card> {
    const card = await this.cardRepository.findOne({
      where: { id: cardId, userId },
    });

    if (!card) {
      throw new BadRequestException(AppError.CARD_NOT_FOUND);
    }

    this.logger.log(`Card with id ${cardId} retrieved for user id: ${userId}`);
    return card;
  }

  // Метод для получения id и labels карточек пользователя
  async getCardIdsAndLabelsForUser(userId: number) {
    try {
      const cards = await this.cardModel.findAll({
        attributes: ["id", "labels"], // Извлечение id и labels
        where: { userId },
      });

      // const ids = cards.map((card) => card.id); // Массив id карточек
      const allLabels = cards.flatMap((card) => card.labels); // Объединение всех labels
      const uniqueLabels = [...new Set(allLabels)]; // Уникальные labels

      return {
        // ids,
        labels: uniqueLabels,
      };
    } catch (error) {
      this.logger.error(
        `Failed to get card IDs and labels for user ${userId}`,
        error,
      );
      throw error;
    }
  }

  // Метод для удаления карточки
  async deleteCard(userId: number, cardId: string): Promise<void> {
    this.logger.log("Attempting to delete card with ID: " + cardId);
    try {
      const card = await this.cardRepository.findOne({
        where: { id: cardId, userId },
      });

      if (!card) {
        this.logger.error(
          `Card with id ${cardId} not found for user id: ${userId}`,
        );
        throw new BadRequestException(AppError.CARD_NOT_FOUND);
      }

      await card.destroy();
      this.logger.log(
        `Card with id ${cardId} deleted successfully for user id: ${userId}`,
      );
    } catch (error) {
      this.logger.error(
        `Error deleting card with id ${cardId} for user ${userId}`,
        error.stack,
      );
      throw error;
    }
  }

  // Метод для удаления указанных меток с карточек пользователя removeLabelsFromUserCards
  async removeLabelsFromCards(
    userId: number,
    labels: string[],
  ): Promise<Card[]> {
    try {
      // Находим все карточки пользователя, которые содержат указанные метки
      const cards = await this.cardModel.findAll({
        where: {
          userId,
          labels: {
            [Op.overlap]: labels, // Используем оператор overlap для поиска пересекающихся меток
          },
        },
      });

      // Обновляем каждую карточку, удаляя указанные метки
      for (const card of cards) {
        card.labels = card.labels.filter((label) => !labels.includes(label));
        await card.save(); // Сохраняем обновленную карточку
      }

      return cards; // Возвращаем обновленные карточки
    } catch (error) {
      throw new Error("Failed to remove labels");
    }
  }
}
